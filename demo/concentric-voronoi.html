<HTML>
	<HEAD>
		<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-5">

		<!-- 
		https://www.youtube.com/watch?v=nT_Oaz1fSEc
		https://www.youtube.com/watch?v=_bdcQXMQ4e0
		https://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm
		-->

		<SCRIPT TYPE="text/javascript" SRC="../js/throw-shade.js"></SCRIPT>
		<SCRIPT TYPE="text/javascript">
			const SHADY_MANUAL = true;

			window.addEventListener('load', () => {
				const config = { uniforms: ShadyLadyUtil.createRanges({
					u1:'0,1,.04',
					u2:'0,1,.12',
					vv:'1,33,14',
					sp:'.01,.1,.04',
					s1:'.01,.13,.0940',
					s2:'.01,.13,.0520',
					dd:'1,17,2.12',
				},ShadyLadyUtil.firstTag('ranges'))};

				const shadyLady = new ShadyLady( config );
			});

	   	</SCRIPT>
	</HEAD>
	<BODY>
		<ranges></ranges>
		<SHADY>
			#include es300-boilerplate.frag
			#include uniforms.frag

			uniform float u1, u2, vv, sp, s1, s2, dd;

			float circle( vec2 uv, float moddo ) {
				float t = mod( sp * iTime, 1000. * moddo );

				float w = mod( length( uv ) - t, moddo );
				return 1. - smoothstep( s1, s2, w );//.0940, .0520, w );
			}

			//https://www.shadertoy.com/view/7slGDN
			#define FBI(k) floatBitsToInt(dot(k,k))^floatBitsToInt(k)

			float hash(vec2 p) {
				ivec2 q = FBI( p );
				return float( q * q * q ) / 2.14e9;
			}

			vec2 hash2(vec2 p ) {
				return fract( vec2( 
					hash( p + vec2( .3183099, .3678794 ) ),
					hash( p + vec2( .1357911, .6384210 ) )
				));
			}

			vec2 hash22( in vec2 uv ) {
				vec3 q = fract( uv.xyx * vec3( 19.191, 53.733, 73.761 ) );
				q += dot( q, q + vec3( 41.557, 23.929, 37.983 ) );
				return fract( vec2( q.x * q.y, q.y * q.z ) );
			}

			vec3 voronoiClosest( vec3 current, vec2 st, vec2 id, vec2 neighbor ) {
				vec2 pt = hash2( id + neighbor );
				st -= pt + neighbor;
				float v = dot( st, st );

				// trying to avoid the if ... :-/
				float p = step( current.x, v );
				return ( p * current ) + ( ( 1. - p ) * vec3( v, neighbor ) );

				return ( current.x < v ) ? current : vec3( v, neighbor );
			}

			/* returns {x:distance,yz:neighborId} */
			vec3 voronoiWhich( vec2 uv, float scale ) {
				uv *= scale;
				vec2 id = floor( uv );
				uv -= id;

				vec3 current = vec3( 1e33 );

				current = voronoiClosest( current, uv, id, vec2( -1., -1. ) );
				current = voronoiClosest( current, uv, id, vec2( -1., -0. ) );
				current = voronoiClosest( current, uv, id, vec2( -1., +1. ) );

				current = voronoiClosest( current, uv, id, vec2( -0., -1. ) );
				current = voronoiClosest( current, uv, id, vec2( -0., -0. ) );
				current = voronoiClosest( current, uv, id, vec2( -0., +1. ) );

				current = voronoiClosest( current, uv, id, vec2( +1., -1. ) );
				current = voronoiClosest( current, uv, id, vec2( +1., -0. ) );
				current = voronoiClosest( current, uv, id, vec2( +1., +1. ) );

				current.yz += id;

				return current;
			}

			float voronoiCircle( vec2 uv ) {
				vec3 v3 = voronoiWhich( uv, vv ); // vv = 14 is good
				float c = circle( v3.yz * u1, u2 ); // u1 = .04, u2 = .12 is nice :-)

				//float d = 1. - sqrt(dot( uv, uv )) * dd;// 2.;
				float d = 1. - pow( length( uv ), 1. / dd );
				return d * c;
			}

			// terrain casting 
			#include raymarching/make-camera.glsl

			float map( vec3 p ) {
				// make things blockier:
				float m = .077;
				vec3 q = floor( p / m ) * m;
           		float h = voronoiCircle( q.xz );

				// height
				if ( h < .02 ) h = .0;

				return h;
        	}

			vec4 mapTerrain( vec3 eye, vec3 direction, float maxDistance ) {
				vec3 p = eye;
				for( float t = .0 ; t < maxDistance ; t += .01 ) {
					float h = map( p );


					if ( p.y < h ) {
						return vec4( p, t );
					}
					p = eye + direction * t;
				}

				return vec4( 2021.2022 );
			}

			vec4 terrainCaster( vec2 uv, float maxDistance ) {
				float d = .0;

				float cameraDistance = 2.;
				float angleF = 1.33;
				float angleX = iMouse.x * angleF;
				float angleY = iMouse.y * angleF;
				if ( .0 > iMouse.z ) {
					angleX = .0;
					angleY = .77;
				}

				vec3 eye = vec3( cameraDistance * sin( angleX ) , cameraDistance * sin( angleY ),  cameraDistance * cos( angleX ) );
    			vec3 target = vec3( 0 );
    			vec3 direction = normalize( makeCamera( eye, target, .0 ) * vec3( uv, 1. ) );

				return mapTerrain( eye, direction, maxDistance );
			}

			// https://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm
            vec3 terrainNormal( vec3 p ) {
                vec2 q = p.xz;
                vec2 ips = vec2( .01, .0 );
                return normalize(
                    vec3(
                        voronoiCircle(q - ips.xy ) - voronoiCircle( q +ips.xy ),
                        2.0f*ips.x,
                        voronoiCircle(q-ips.yx) - voronoiCircle(q+ips.yx)
                    )
                );
            }

			void main() {
				vec2 uv = ( gl_FragCoord.xy - .5 * iResolution.xy ) / iResolution.y;

				float vc = voronoiCircle( uv );

				//fragColor = vec4( vec3( vc ), 1. ); return;

				fragColor = .11 * vec4( vec3( vc ), 1. );

				float maxDistance = 33.;
				vec4 at = terrainCaster( uv, maxDistance );
				if ( at.z < maxDistance ) {
					float fog = at.z / maxDistance;

					vec3 n = terrainNormal( at.xyz );
					vec3 color = (
						+ .4 * abs( at.xyz ) 
						+ .7 * fog
						+ .4 * vec3( n.x * .3, n.y * .4, n.z * .3 )
					);

					color = mix( color, vec3( .3 ), fog );

					fragColor = vec4( color, 1. );
				} else {
					fragColor = vec4( vec3( .8), 1. );
				}
			}
		</SHADY>
	</BODY>
</HTML>
