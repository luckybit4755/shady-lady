<HTML>
	<HEAD>
		<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-5">

		<!-- 
		https://www.youtube.com/watch?v=nT_Oaz1fSEc
		https://www.youtube.com/watch?v=_bdcQXMQ4e0
		-->

		<SCRIPT TYPE="text/javascript" SRC="../js/throw-shade.js"></SCRIPT>
		<SCRIPT TYPE="text/javascript">
			const SHADY_MANUAL = true;

			window.addEventListener('load', () => {
				const config = { uniforms: ShadyLadyUtil.createRanges({
				},ShadyLadyUtil.firstTag('ranges'))};

				const shadyLady = new ShadyLady( config );
			});

	   	</SCRIPT>
	</HEAD>
	<BODY>
		<ranges></ranges>
		<SHADY>
			#include es300-boilerplate.frag
			#include uniforms.frag

			float circle( vec2 uv, float moddo ) {
				float q = .11;
				float t = mod( .1 * iTime, 1000. * moddo );

				float w = mod( length( uv ) - t, moddo );
				return 1. - smoothstep( .0940, .0520, w );
			}

			//https://www.shadertoy.com/view/7slGDN
			#define FBI(k) floatBitsToInt(dot(k,k))^floatBitsToInt(k)

			float hash(vec2 p) {
				ivec2 q = FBI( p );
				return float( q * q * q ) / 2.14e9;
			}

			vec2 hash2(vec2 p ) {
				return fract( vec2( 
					hash( p + vec2( .3183099, .3678794 ) ),
					hash( p + vec2( .1357911, .6384210 ) )
				));
			}

			vec2 hash22( in vec2 uv ) {
				vec3 q = fract( uv.xyx * vec3( 19.191, 53.733, 73.761 ) );
				q += dot( q, q + vec3( 41.557, 23.929, 37.983 ) );
				return fract( vec2( q.x * q.y, q.y * q.z ) );
			}

			float voronoiDistance( vec2 st, vec2 id, vec2 neighbor ) {
				vec2 pt = hash2( id + neighbor );
				st -= pt + neighbor;
				return dot( st, st );
			}

			/* returns {x:distance,yz:neighborId} */
			vec3 voronoiWhich( vec2 uv, float scale ) {
				uv *= scale;
				vec2 id = floor( uv );
				uv -= id;

				vec3 n;
				vec3 d = vec3( 1e33 );
n.yz = vec2( -1., -1. ); n.x = voronoiDistance( uv, id, n.yz ); if ( n.x < d.x ) d = n;
n.yz = vec2( -1., .0  ); n.x = voronoiDistance( uv, id, n.yz ); if ( n.x < d.x ) d = n;
n.yz = vec2( -1., +1. ); n.x = voronoiDistance( uv, id, n.yz ); if ( n.x < d.x ) d = n;

n.yz = vec2( .0,  -1. ); n.x = voronoiDistance( uv, id, n.yz ); if ( n.x < d.x ) d = n;
n.yz = vec2( .0,  .0  ); n.x = voronoiDistance( uv, id, n.yz ); if ( n.x < d.x ) d = n;
n.yz = vec2( .0,  +1. ); n.x = voronoiDistance( uv, id, n.yz ); if ( n.x < d.x ) d = n;

n.yz = vec2( +1., -1. ); n.x = voronoiDistance( uv, id, n.yz ); if ( n.x < d.x ) d = n;
n.yz = vec2( +1., .0  ); n.x = voronoiDistance( uv, id, n.yz ); if ( n.x < d.x ) d = n;
n.yz = vec2( +1., +1. ); n.x = voronoiDistance( uv, id, n.yz ); if ( n.x < d.x ) d = n;

				d.yz += id;

				return d;
			}

			float voronoi( vec2 uv, float scale ) {
				uv *= scale;
				vec2 st = fract( uv );
				vec2 id = floor( uv );

				float s = sqrt( 2. );

				float d = 1e33;

				d = min( d, voronoiDistance( st, id, vec2(  .0, .0 ) ) );

				d = min( d, voronoiDistance( st, id, vec2( +1., .0 ) ) );
				d = min( d, voronoiDistance( st, id, vec2( -1., .0 ) ) );
				d = min( d, voronoiDistance( st, id, vec2( .0, +1. ) ) );
				d = min( d, voronoiDistance( st, id, vec2( .0, -1. ) ) );

				d = min( d, voronoiDistance( st, id, vec2( +1., +1. ) ) );
				d = min( d, voronoiDistance( st, id, vec2( -1., -1. ) ) );
				d = min( d, voronoiDistance( st, id, vec2( -1., +1. ) ) );
				d = min( d, voronoiDistance( st, id, vec2( +1., -1. ) ) );

				return sqrt( d * scale * .1 );
			}

			void main() {
				vec2 uv = ( gl_FragCoord.xy - .5 * iResolution.xy ) / iResolution.y;

				float c = circle( uv, .11 );

				float v = voronoi( uv, 10. );
				vec3 v3 = voronoiWhich( uv, 10. );
				vec3 vq = voronoiWhich( uv + c * .7, 10. );


				fragColor = vec4( vec3( v - c ), 1. );
				fragColor = vec4( vec3( c - v ), 1. );
				fragColor = vec4( c, v, v * c, 1. );

				fragColor = vec4( abs( v3.xyz ) * v3.x * c, 1. );
				fragColor = vec4( abs( v3.xyz ) * v3.x + c, 1. );
				fragColor = vec4( abs( v3.xyz ) * c, 1. );

				vec2 ug = fract( abs( v3.yz * .1 ) );
				fragColor = vec4( ug.xyx * c, 1. );

				vec2 uk = fract( abs( vq.yz * .1 ) );
				fragColor = vec4( uk.xyx * c, 1. );
				fragColor = vec4( uk.xyx * c - ug.xyx * c, 1. );

				float o = circle( uv + v3.yz, .15 );
				fragColor = vec4( vec3( o, o, o ) * uk.x, 1. );
			}
		</SHADY>
	</BODY>
</HTML>
